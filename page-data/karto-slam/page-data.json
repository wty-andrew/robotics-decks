{"componentChunkName":"component---node-modules-gatsby-theme-mdx-deck-src-templates-deck-js","path":"/karto-slam","matchPath":"/karto-slam/*","result":{"data":{"deck":{"id":"90c4b51a-4635-53ed-9713-0a53b42dfaf2","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _templateObject17() {\n  var data = _taggedTemplateLiteral([\"\\n  \\begin{aligned}\\n    \\frac{partial{e_{ij}}}{partial{t_i}} & equiv\\n      \\begin{bmatrix}\\n        -R^\\top_i \\\\\\n        0enspace 0\\n      end{bmatrix} \\\\\\n    \\frac{partial{e_{ij}}}{partial{t_j}} & equiv\\n      \\begin{bmatrix}\\n        R^\\top_i \\\\\\n        0enspace 0\\n      end{bmatrix}\\n  end{aligned}\\n  quad\\n  \\begin{aligned}\\n    \\frac{partial{e_{ij}}}{partial{\\theta_i}} & equiv\\n      \\begin{bmatrix}\\n        -\\frac{partial{R^\\top_i}}{partial{\\theta_i}}(t_j - t_i) \\\\\\n        -1\\n      end{bmatrix} \\\\\\n    \\frac{partial{e_{ij}}}{partial{\\theta_j}} & equiv\\n      \\begin{bmatrix}\\n        0 & 0 & 1\\n      end{bmatrix}^\\top\\n  end{aligned}\\n\"], [\"\\n  \\\\begin{aligned}\\n    \\\\frac{\\\\partial{e_{ij}}}{\\\\partial{t_i}} & \\\\equiv\\n      \\\\begin{bmatrix}\\n        -R^\\\\top_i \\\\\\\\\\n        0\\\\enspace 0\\n      \\\\end{bmatrix} \\\\\\\\\\n    \\\\frac{\\\\partial{e_{ij}}}{\\\\partial{t_j}} & \\\\equiv\\n      \\\\begin{bmatrix}\\n        R^\\\\top_i \\\\\\\\\\n        0\\\\enspace 0\\n      \\\\end{bmatrix}\\n  \\\\end{aligned}\\n  \\\\quad\\n  \\\\begin{aligned}\\n    \\\\frac{\\\\partial{e_{ij}}}{\\\\partial{\\\\theta_i}} & \\\\equiv\\n      \\\\begin{bmatrix}\\n        -\\\\frac{\\\\partial{R^\\\\top_i}}{\\\\partial{\\\\theta_i}}(t_j - t_i) \\\\\\\\\\n        -1\\n      \\\\end{bmatrix} \\\\\\\\\\n    \\\\frac{\\\\partial{e_{ij}}}{\\\\partial{\\\\theta_j}} & \\\\equiv\\n      \\\\begin{bmatrix}\\n        0 & 0 & 1\\n      \\\\end{bmatrix}^\\\\top\\n  \\\\end{aligned}\\n\"]);\n\n  _templateObject17 = function _templateObject17() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject16() {\n  var data = _taggedTemplateLiteral([\"\\n  (\\bold{H} + lambda \\textit{diag} \\bold{H})Delta \\bold{x} = \\bold{J}^\\top \\bold{Lambda} \\bold{e}\\n\"], [\"\\n  (\\\\bold{H} + \\\\lambda \\\\textit{diag} \\\\bold{H})\\\\Delta \\\\bold{x} = \\\\bold{J}^\\\\top \\\\bold{\\\\Lambda} \\\\bold{e}\\n\"]);\n\n  _templateObject16 = function _templateObject16() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject15() {\n  var data = _taggedTemplateLiteral([\"\\n  \\begin{aligned}\\n    \\bold{Lambda} & equiv\\n      \\begin{bmatrix}\\n        Lambda_{ab} &        & \\\\\\n                     & ddots & \\\\\\n                     &        & Lambda_{mn}\\n      end{bmatrix} \\\\[3ex]\\n    \\bold{J} & equiv \\frac{partial{\\bold{e}}}{partial{\\bold{x}}} \\\\[1.5ex]\\n    \\bold{H} & equiv \\bold{J}^\\top \\bold{Lambda} \\bold{J} \\\\\\n  end{aligned}\\n\"], [\"\\n  \\\\begin{aligned}\\n    \\\\bold{\\\\Lambda} & \\\\equiv\\n      \\\\begin{bmatrix}\\n        \\\\Lambda_{ab} &        & \\\\\\\\\\n                     & \\\\ddots & \\\\\\\\\\n                     &        & \\\\Lambda_{mn}\\n      \\\\end{bmatrix} \\\\\\\\[3ex]\\n    \\\\bold{J} & \\\\equiv \\\\frac{\\\\partial{\\\\bold{e}}}{\\\\partial{\\\\bold{x}}} \\\\\\\\[1.5ex]\\n    \\\\bold{H} & \\\\equiv \\\\bold{J}^\\\\top \\\\bold{\\\\Lambda} \\\\bold{J} \\\\\\\\\\n  \\\\end{aligned}\\n\"]);\n\n  _templateObject15 = function _templateObject15() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject14() {\n  var data = _taggedTemplateLiteral([\"e^\\top_{ij} Lambda_{ij} e_{ij}\"], [\"e^\\\\top_{ij} \\\\Lambda_{ij} e_{ij}\"]);\n\n  _templateObject14 = function _templateObject14() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject13() {\n  var data = _taggedTemplateLiteral([\"[-pi,pi)\"], [\"[-\\\\pi,\\\\pi)\"]);\n\n  _templateObject13 = function _templateObject13() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject12() {\n  var data = _taggedTemplateLiteral([\"\\n          h(c_i, c_j) equiv\\n          \\begin{cases}\\n            R^\\top_i (t_j - t_i) \\\\\\n            \\theta_j - \\theta_i\\n          end{cases}\\n        \"], [\"\\n          h(c_i, c_j) \\\\equiv\\n          \\\\begin{cases}\\n            R^\\\\top_i (t_j - t_i) \\\\\\\\\\n            \\\\theta_j - \\\\theta_i\\n          \\\\end{cases}\\n        \"]);\n\n  _templateObject12 = function _templateObject12() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject11() {\n  var data = _taggedTemplateLiteral([\"\\\\e_{ij} equiv h(c_i, c_j) - \\bar{z}_{ij}\"], [\"\\\\\\\\e_{ij} \\\\equiv h(c_i, c_j) - \\\\bar{z}_{ij}\"]);\n\n  _templateObject11 = function _templateObject11() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject10() {\n  var data = _taggedTemplateLiteral([\"\\n  \\begin{aligned}\\n    e_{ij}                      & equiv \\bar{z}_{ij} - h(c_i, c_j) \\\\\\n    chi^2 (\\bold{c}, \\bold{p}) & equiv sum_{ij} e^\\top_{ij} Lambda_{ij} e_{ij}\\n  end{aligned}\\n\"], [\"\\n  \\\\begin{aligned}\\n    e_{ij}                      & \\\\equiv \\\\bar{z}_{ij} - h(c_i, c_j) \\\\\\\\\\n    \\\\chi^2 (\\\\bold{c}, \\\\bold{p}) & \\\\equiv \\\\sum_{ij} e^\\\\top_{ij} \\\\Lambda_{ij} e_{ij}\\n  \\\\end{aligned}\\n\"]);\n\n  _templateObject10 = function _templateObject10() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject9() {\n  var data = _taggedTemplateLiteral([\"\\n  h(c_i, c_j) equiv\\n  \\begin{cases}\\n    R^\\top_i (t_j - t_i) \\\\\\n    \\theta_j - \\theta_i\\n  end{cases}\\n\"], [\"\\n  h(c_i, c_j) \\\\equiv\\n  \\\\begin{cases}\\n    R^\\\\top_i (t_j - t_i) \\\\\\\\\\n    \\\\theta_j - \\\\theta_i\\n  \\\\end{cases}\\n\"]);\n\n  _templateObject9 = function _templateObject9() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject8() {\n  var data = _taggedTemplateLiteral([\"c_i = [t_i, \\theta_i] = [x_i, y_i, \\theta_i]^\\top\"], [\"c_i = [t_i, \\\\theta_i] = [x_i, y_i, \\\\theta_i]^\\\\top\"]);\n\n  _templateObject8 = function _templateObject8() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject7() {\n  var data = _taggedTemplateLiteral([\"\\bold{c}\"], [\"\\\\bold{c}\"]);\n\n  _templateObject7 = function _templateObject7() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject6() {\n  var data = _taggedTemplateLiteral([\"\\n            g(x,y) = \\frac{1}{2pi sigma^2} mathrm{e}^{-\\frac{x^2 + y^2}{2sigma^2}}\\n          \"], [\"\\n            g(x,y) = \\\\frac{1}{2\\\\pi \\\\sigma^2} \\\\mathrm{e}^{-\\\\frac{x^2 + y^2}{2\\\\sigma^2}}\\n          \"]);\n\n  _templateObject6 = function _templateObject6() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject5() {\n  var data = _taggedTemplateLiteral([\"\\n  \\begin{aligned}\\n    p(z | x_i, m) & = prod_j p(z_j | x_i, m) \\\\\\n    implies log{p(z | x_i, m)} & = sum_j log{p(z_j | x_i, m)}\\n  end{aligned}\\n\"], [\"\\n  \\\\begin{aligned}\\n    p(z | x_i, m) & = \\\\prod_j p(z_j | x_i, m) \\\\\\\\\\n    \\\\implies \\\\log{p(z | x_i, m)} & = \\\\sum_j \\\\log{p(z_j | x_i, m)}\\n  \\\\end{aligned}\\n\"]);\n\n  _templateObject5 = function _templateObject5() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject4() {\n  var data = _taggedTemplateLiteral([\"z_j\"]);\n\n  _templateObject4 = function _templateObject4() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject3() {\n  var data = _taggedTemplateLiteral([void 0], [\"\\n  p(x_i | x_{i-1}, u, m, z) \\\\propto \\\\underbrace{p(z | x_i, m)}_{\\\\text{observation model}} \\\\underbrace{p(x_i | x_{i-1}, u)}_{\\\\text{motion model}}\\n\"]);\n\n  _templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteral([void 0], [\"\\n      \\\\begin{aligned}\\n        p(l | r, m) & = k \\\\cdot \\\\underbrace{p(r | l, m)}_{\\\\text{sensor response}} p(l, m)\\\\\\\\\\n        p(r | l, m) & \\\\approx \\\\sum_i{p(r_i)p(m_i)}\\n      \\\\end{aligned}\\n    \"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"scriptsize l\\text{: robot pose}, r\\text{: map patch}, m\\text{: old map}\"], [\"\\\\scriptsize l\\\\text{: robot pose}, r\\\\text{: map patch}, m\\\\text{: old map}\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar theme = customTheme;\nvar _frontmatter = {};\nvar layoutProps = {\n  theme: theme,\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(Hero, {\n    title: \"Karto SLAM\",\n    mdxType: \"Hero\"\n  }), mdx(\"hr\", null), mdx(\"h1\", null, \"Outline\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Incremental Mapping of Large Cyclic Environments\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Real-Time Correlative Scan Matching\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Efficient Sparse Pose Adjustment for 2D Mapping\")), mdx(\"hr\", null), mdx(\"h1\", null, \"Outline\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Incremental Mapping of Large Cyclic Environments\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Real-Time Correlative Scan Matching\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Efficient Sparse Pose Adjustment for 2D Mapping\")), mdx(\"hr\", null), mdx(\"h2\", null, \"Incremental Mapping of Large Cyclic Environments\"), mdx(\"p\", null, \"Propose the Local Registration and Global Correlation (LRGC) method which\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"adds new information to the current map efficiently\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"determines topologically correct relations between the poses\")), mdx(\"hr\", null), mdx(\"h2\", null, \"Consistent Pose Estimation\"), mdx(\"img\", {\n    src: consistentPoseEstimationImg,\n    style: {\n      maxHeight: '50vh',\n      objectFit: 'contain',\n      marginBottom: '-1em'\n    }\n  }), mdx(\"p\", null, \"Consider the full pose set in system and try to minimize the total error, can work on cyclic environments\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Local Registration and Global Correlation\"), mdx(\"img\", {\n    src: localRegistrationImg,\n    style: {\n      maxHeight: '45vh',\n      objectFit: 'contain',\n      marginBottom: '-0.5em'\n    }\n  }), mdx(\"p\", null, \"A newly added pose will have a link to the previous pose and also to several of the previous poses based on scan overlaps\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Local Registration and Global Correlation\"), mdx(\"div\", {\n    style: {\n      display: 'flex'\n    }\n  }, mdx(\"img\", {\n    src: mapCorrelationImg,\n    style: {\n      maxWidth: '30vw',\n      maxHeight: '60vh',\n      objectFit: 'contain'\n    }\n  }), mdx(\"div\", null, \"Try to find loop closure by comparing a set of local scans with the old map\", mdx(\"br\", null), mdx(\"br\", null), mdx(Tex, {\n    mdxType: \"Tex\"\n  }, String.raw(_templateObject())), mdx(Tex, {\n    block: true,\n    mdxType: \"Tex\"\n  }, String.raw(_templateObject2())))), mdx(\"hr\", null), mdx(\"h2\", null, \"Local Registration and Global Correlation\"), mdx(\"p\", null, \"It's not possible to undo the correction operation so false positive rejection is critical, some good criteria are\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"High match score\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Low ambiguity, the ratio of the highest peak to the next highest should be large\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Low variance\")), mdx(\"hr\", null), mdx(\"h2\", null, \"Incremental, Consistent Mapping\"), mdx(\"img\", {\n    src: incrementalMappingDataFlowImg,\n    style: {\n      maxHeight: '70%',\n      objectFit: 'contain'\n    }\n  }), mdx(\"hr\", null), mdx(CodeSurfer, {\n    language: 'cpp',\n    customStyle: {\n      fontSize: '1rem'\n    },\n    style: {\n      gridTemplateRows: '10% 1fr 20%'\n    },\n    title: function title() {\n      return mdx(CodeTitle, {\n        title: \"slam_toolbox/lib/karto_sdk/src/Mapper.cpp\",\n        mdxType: \"CodeTitle\"\n      });\n    },\n    steps: [{\n      code: mapperProcessSnippet,\n      note: 'The Process function is triggered when a laser scan is received'\n    }, {\n      code: mapperProcessSnippet,\n      note: 'The scan will be linked with previous scan, running scans, and near chains of scans',\n      highlightLines: '10'\n    }, {\n      code: mapperProcessSnippet,\n      note: 'Loop detection is activated with each new scan',\n      highlightLines: '15'\n    }],\n    mdxType: \"CodeSurfer\"\n  }), mdx(\"hr\", null), mdx(CodeSurfer, {\n    language: 'cpp',\n    customStyle: {\n      fontSize: '1rem'\n    },\n    style: {\n      gridTemplateRows: '10% 1fr 20%'\n    },\n    title: function title() {\n      return mdx(CodeTitle, {\n        title: \"slam_toolbox/lib/karto_sdk/src/Mapper.cpp\",\n        mdxType: \"CodeTitle\"\n      });\n    },\n    steps: [{\n      code: tryCloseLoopSnippet,\n      note: 'There are two ScanMatcher instances used to find the best pose/response',\n      highlightLines: '5,6,11,12'\n    }, {\n      code: tryCloseLoopSnippet,\n      note: function note() {\n        return mdx(\"table\", {\n          style: {\n            fontSize: '0.6em'\n          }\n        }, mdx(\"thead\", null, mdx(\"tr\", null, mdx(\"th\", null, \"Scan Matcher\"), mdx(\"th\", null, \"Search Dimension\"), mdx(\"th\", null, \"Search Resolution\"), mdx(\"th\", null, \"Smear Deviation\"))), mdx(\"tbody\", null, mdx(\"tr\", null, mdx(\"td\", null, \"sequential\"), mdx(\"td\", null, \"0.5 meters\"), mdx(\"td\", null, \"0.01 meters\"), mdx(\"td\", null, \"0.01 meters\")), mdx(\"tr\", null, mdx(\"td\", null, \"loop\"), mdx(\"td\", null, \"8 meters\"), mdx(\"td\", null, \"0.05 meters\"), mdx(\"td\", null, \"0.03 meters\"))));\n      },\n      highlightLines: '5,6,11,12'\n    }, {\n      code: tryCloseLoopSnippet,\n      note: 'False positive rejection',\n      highlightLines: '7-9,13'\n    }],\n    mdxType: \"CodeSurfer\"\n  }), mdx(\"hr\", null), mdx(\"h1\", null, \"Outline\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Incremental Mapping of Large Cyclic Environments\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Real-Time Correlative Scan Matching\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Efficient Sparse Pose Adjustment for 2D Mapping\")), mdx(\"hr\", null), mdx(\"h2\", null, \"Real-Time Correlative Scan Matching\"), mdx(\"p\", null, \"Advocate a probabilistically-motivated scan matching approach based upon correlations\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Probabilistic Formulation\"), mdx(\"img\", {\n    src: graphicalModelForProbabilisticScanMatchingImg,\n    style: {\n      maxHeight: '50vh',\n      objectFit: 'contain',\n      marginBottom: '-1em'\n    }\n  }), mdx(Tex, {\n    block: true,\n    mdxType: \"Tex\"\n  }, String.raw(_templateObject3())), mdx(\"hr\", null), mdx(\"h2\", null, \"Probabilistic Formulation\"), mdx(\"p\", null, \"Assume each individual lidar return \", mdx(Tex, {\n    mdxType: \"Tex\"\n  }, String.raw(_templateObject4())), \" is independent\"), mdx(Tex, {\n    block: true,\n    mdxType: \"Tex\"\n  }, String.raw(_templateObject5())), mdx(\"hr\", null), mdx(\"h2\", null, \"Lookup-Table Rasterization\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Precompute lookup table containing log probabilities of lidar observation at each position in the world\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Approximate the potentially banana-shaped distribution arising from the sensor model as a radially-symmetric distribution\")), mdx(\"hr\", null), mdx(CodeSurfer, {\n    language: 'cpp',\n    customStyle: {\n      fontSize: '1.2rem'\n    },\n    style: {\n      gridTemplateRows: '10% 1fr 20%'\n    },\n    title: function title() {\n      return mdx(CodeTitle, {\n        title: \"slam_toolbox/lib/karto_sdk/src/Mapper.cpp\",\n        mdxType: \"CodeTitle\"\n      });\n    },\n    steps: [{\n      code: smearPointSnippet,\n      note: 'SmearPoint is called when building CorrelationGrid, it applies the kernel at each occupied cell'\n    }, {\n      code: smearPointSnippet,\n      note: 'The probabilities of nearby points of an occupied cell are raised to kernel value',\n      highlightLines: '11,12'\n    }, {\n      code: calculateKernelSnippet,\n      note: function note() {\n        return mdx(\"div\", null, \"The used kernel is Gaussian: \\xA0\", mdx(Tex, {\n          mdxType: \"Tex\"\n        }, String.raw(_templateObject6())));\n      },\n      highlightLines: '6,7'\n    }, {\n      code: scanMatcherGetResponseSnippet,\n      note: 'The response is calculated by adding up the probabilities stored in CorrelationGrid',\n      highlightLines: '3,7-10'\n    }],\n    mdxType: \"CodeSurfer\"\n  }), mdx(\"hr\", null), mdx(\"h2\", null, \"Multi-Level Resolution Implementation\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Brute Force\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Computing 2D Slices\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Multi-Level Resolution\")), mdx(\"hr\", null), mdx(CodeSurfer, {\n    language: 'cpp',\n    customStyle: {\n      fontSize: '1rem'\n    },\n    style: {\n      gridTemplateRows: '10% 1fr 20%'\n    },\n    steps: [{\n      code: matchScanSnippet,\n      title: function title() {\n        return mdx(CodeTitle, {\n          title: \"slam_toolbox/lib/karto_sdk/src/Mapper.cpp\",\n          mdxType: \"CodeTitle\"\n        });\n      },\n      note: 'CorrelateScan are performed at different resolution, the search center of fine scan comes from the result of coarse scan',\n      highlightLines: '4-7,12-14'\n    }, {\n      code: computeOffsetsSnippet,\n      title: function title() {\n        return mdx(CodeTitle, {\n          title: \"slam_toolbox/lib/karto_sdk/include/karto_sdk/Karto.h\",\n          mdxType: \"CodeTitle\"\n        });\n      },\n      note: 'ComputeOffsets caches the relative offsets into LookupArray for each \"search\" angle',\n      highlightLines: '2-4'\n    }, {\n      code: computeOffsetsSnippet,\n      title: function title() {\n        return mdx(CodeTitle, {\n          title: \"slam_toolbox/lib/karto_sdk/include/karto_sdk/Karto.h\",\n          mdxType: \"CodeTitle\"\n        });\n      },\n      note: 'Each search angle has n entries where n is the number of readings from a single scan',\n      highlightLines: '2,6,14'\n    }, {\n      code: correlateScanSnippet,\n      title: function title() {\n        return mdx(CodeTitle, {\n          title: \"slam_toolbox/lib/karto_sdk/src/Mapper.cpp\",\n          mdxType: \"CodeTitle\"\n        });\n      },\n      note: 'CorrelateScan finds the highest response by searching through all the x, y, Î¸ combination in search space',\n      highlightLines: '6-15'\n    }],\n    mdxType: \"CodeSurfer\"\n  }), mdx(\"hr\", null), mdx(\"h1\", null, \"Outline\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Incremental Mapping of Large Cyclic Environments\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Real-Time Correlative Scan Matching\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Efficient Sparse Pose Adjustment for 2D Mapping\"))), mdx(\"hr\", null), mdx(\"h2\", null, \"Efficient Sparse Pose Adjustment for 2D Mapping\"), mdx(\"p\", null, \"Propose an efficient approach for optimizing 2D pose graphs that uses direct sparse Cholesky decomposition to solve the linear system\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Pose Graph\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Nodes: robot poses, landmarks\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Edges: measurements as constraints\")), mdx(\"p\", null, \"Goal: Jointly optimize the poses of the nodes so as to minimize the error introduced by the contraint\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Graph-Based SLAM System\"), mdx(\"img\", {\n    src: graphBasedSLAMSystemImg\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"front-end: data association\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"back-end: robot poses correction\")), mdx(\"hr\", null), mdx(\"h2\", null, \"Sparse Pose Adjustment (SPA)\"), mdx(\"p\", null, \"Efficiently compute the sparse matrix from the constraint graph, and use direct sparse linear methods to solve it\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Error Formulation\"), mdx(\"div\", null, mdx(Tex, {\n    mdxType: \"Tex\"\n  }, String.raw(_templateObject7())), \"\\xA0: the set of global poses, \\xA0\", mdx(Tex, {\n    mdxType: \"Tex\"\n  }, String.raw(_templateObject8()))), mdx(Tex, {\n    block: true,\n    mdxType: \"Tex\"\n  }, String.raw(_templateObject9())), mdx(Tex, {\n    block: true,\n    mdxType: \"Tex\"\n  }, String.raw(_templateObject10())), mdx(\"hr\", null), mdx(CodeSurfer, {\n    language: 'cpp',\n    code: poseGraph2dErrorTermSnippet,\n    customStyle: {\n      fontSize: '1rem'\n    },\n    style: {\n      gridTemplateRows: '10% 1fr 20%'\n    },\n    title: function title() {\n      return mdx(CodeTitle, {\n        title: \"slam_toolbox/solvers/ceres_utils.h\",\n        mdxType: \"CodeTitle\"\n      });\n    },\n    steps: [{}, {\n      note: function note() {\n        return mdx(Tex, {\n          mdxType: \"Tex\"\n        }, String.raw(_templateObject11()));\n      },\n      highlightLines: '9-11'\n    }, {\n      note: function note() {\n        return mdx(Tex, {\n          mdxType: \"Tex\"\n        }, String.raw(_templateObject12()));\n      },\n      highlightLines: '10,11'\n    }, {\n      note: function note() {\n        return mdx(\"div\", null, \"Note the angle difference must be normalized to \\xA0\", mdx(Tex, {\n          mdxType: \"Tex\"\n        }, String.raw(_templateObject13())));\n      },\n      highlightLines: '11'\n    }, {\n      note: function note() {\n        return mdx(\"div\", null, \"Account for \\xA0\", mdx(Tex, {\n          mdxType: \"Tex\"\n        }, String.raw(_templateObject14())));\n      },\n      highlightLines: '13'\n    }],\n    mdxType: \"CodeSurfer\"\n  }), mdx(\"hr\", null), mdx(\"h2\", null, \"Linear System\"), mdx(\"div\", {\n    style: {\n      fontSize: '0.8em'\n    }\n  }, mdx(Tex, {\n    block: true,\n    mdxType: \"Tex\"\n  }, String.raw(_templateObject15())), mdx(\"p\", null, \"The large sparse linear problem is solved by Levenberg-Marquardt\"), mdx(Tex, {\n    block: true,\n    mdxType: \"Tex\"\n  }, String.raw(_templateObject16()))), mdx(\"hr\", null), mdx(\"h2\", null, \"Error Jacobians\"), mdx(\"p\", null, \"The Jacobians of the measurement function\"), mdx(Tex, {\n    block: true,\n    mdxType: \"Tex\"\n  }, String.raw(_templateObject17())), mdx(\"p\", null, \"In the implementation, the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://ceres-solver.org/nnls_modeling.html#autodiffcostfunction\"\n  }), \"AutoDiffCostFunction\"), \"\\nis used instead of providing the analytic derivatives\"), mdx(\"hr\", null), mdx(\"h2\", null, \"References\"), mdx(\"div\", {\n    style: {\n      fontSize: '.65em'\n    }\n  }, mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Gutmann, J.-S., & Konolige, K. (n.d.). Incremental mapping of large cyclic environments. Proceedings 1999 IEEE International Symposium on Computational Intelligence in Robotics and Automation. CIRA\\u201999 (Cat. No.99EX375), 318\\u2013325. \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://doi.org/10.1109/CIRA.1999.810068\"\n  }), \"https://doi.org/10.1109/CIRA.1999.810068\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Olson, E. B. (2009). Real-time correlative scan matching. 2009 IEEE International Conference on Robotics and Automation, 68(6), 4387\\u20134393. \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://doi.org/10.1109/ROBOT.2009.5152375\"\n  }), \"https://doi.org/10.1109/ROBOT.2009.5152375\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Konolige, K., Grisetti, G., K\\xFCmmerle, R., Burgard, W., Limketkai, B., & Vincent, R. (2010). Efficient sparse pose adjustment for 2D mapping. IEEE/RSJ 2010 International Conference on Intelligent Robots and Systems, IROS 2010 - Conference Proceedings, 22\\u201329. \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://doi.org/10.1109/IROS.2010.5649043\"\n  }), \"https://doi.org/10.1109/IROS.2010.5649043\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"S. Macenski, slam_toolbox, (2020), GitHub repository, \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/SteveMacenski/slam_toolbox\"\n  }), \"https://github.com/SteveMacenski/slam_toolbox\")))));\n}\n;\nMDXContent.isMDXComponent = true;","title":"Outline"}},"pageContext":{"matchPath":"/karto-slam/*","id":"90c4b51a-4635-53ed-9713-0a53b42dfaf2","slug":"/robotics-decks/karto-slam","title":"Outline"}},"staticQueryHashes":[]}